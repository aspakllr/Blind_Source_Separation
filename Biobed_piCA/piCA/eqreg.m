function [dmin,err_sw] = eqreg(a)
% Finds bordering neighbourhoods around with centers the points at
% the input, so that their intersection is the empty set.
%
% The input vector must be in data samples, not time units.

%??????????????????????????????????????????????????????????????????????????
% The points are sorted from smallest to greatest.
a = sort(a);

%Initiate err sw. Shows if partitioning is possible
err sw = 0;
p = length(a);

% Calculate the difference between all a i and their halves.
diff s = a(2:end) ? a(1:end?1);
h diff s = floor(diff s/2);

%??????????????????????????????????????????????????????????????????????????
% Calculate all A i's and B i's.

A = zeros(p-1,1); A(1) = 1;
B = zeros(p-1,1); B(1) = 0;

for i = 2:(p-1)
    A(i) = -A(i-1);
    B(i) = diff_s(i-1)- 1 - B(i-1);
end

%??????????????????????????????????????????????????????????????????????????
% Calculate the minimum and maximum valid values for d 1 = x.

C = zeros(1,p-1);
D = zeros(1,p-1);

for i = 1:(p-1)
    C(i) = 1-B(i);
    D(i) = diff_s(i)- 2-B(i);
end

for i = 1:(p-1)
    if rem(i,2) == 0
        temp = -C(i);
        C(i) = -D(i);
        D(i) = temp;
    end
end

lim1 = max(C);
lim2 = min(D);

% Normally, we'd need 1 <= d 1 <= a 1 ? 2, so that a 1 ? d 1 is always >= 1
% and all neighbourhoods are in M = f1,2,...,mg,
% but that can make the partitioning too uneven if the first point of
% interest is too close to 1st sample (or the 1st sample itself). So, we
% ignore it. Similarly, we'd need one condition for the last d i, but we
% ignore that too, for the same reason. We modify the 1st and last
% neighbourhoods in piCA peaks so that they all are in M.

%if a(1)?2< lim2 && a(1)?2> lim1
% lim2 = s(1)?2;
%end

%??????????????????????????????????????????????????????????????????????????
% If there are no valid 'x', then return an empty matrix and make
% err sw == 1.

if lim2 < lim1
    warning('Non?existent solution.')
    err_sw = 1;
    dmin = [];
    return
end

%??????????????????????????????????????????????????????????????????????????
% Calculate all possible d i's, find the one whose greatest
% d i is closest to the half point between a i and a fi+1g and return it.

x = lim1:lim2; lx = length(x);
d = A*x + B*ones(1,lx);

temp = d-h_diff_s*ones(1,lx);
E = max(abs(temp));

[~,minE] = min(E);

dmin = d(:,minE);
dmin = [dmin; a(end) - (a(end-1)+1+dmin(end))];


end